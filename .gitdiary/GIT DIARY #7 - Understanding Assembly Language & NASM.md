Before we begin writing code generation, we need to study Assembly language. 

A processor can only understand and execute machine instructions. These instructions are simply binary numbers stored in the computer. Typically, each assembly language instruction is translated into one machine instruction by anÂ **assembler**.

Assembly language isÂ **hardware dependent**, with a different assembly language for each type of processor. In particular, assembly language instructions can make reference to specificÂ *registers*Â in the processor,

include all of theÂ *opcodes*Â of the processor, and reflect the bit length of the various registers of the processor and operands of the machine language.

An assembly language or compiler programmer must therefore understand the computerâ€™s architecture.

Consider the simple statement in the C programming language:

`n = i + j + k;`

Suppose that we want to program this statement in machine language and

the contents of i, j, and k have been initialized to 2, 3, and 4, respectively.

Assume a simple machine with a 16-bit word length consisting of an 8-bit opcode and an 8-bit address, and the only available register is an accumulator (AC).

The binary program for this is shown below:

![](https://miro.medium.com/v2/resize:fit:1097/1*LuyQx02EUURWEExsoppT_g.png)

Memory is reserved for the four variables starting at location 201. The program consists of four instructions:

**1.**Â Load the contents of location 201 into the AC.

**2.**Â Add the contents of location 202 to the AC.

**3.**Â Add the contents of location 203 to the AC.

**4.**Â Store the contents of the AC in location 204.

This is clearly a tedious and very error-prone process

In particular, we have to give an absolute address for each word. This means that the program and data can be loaded into only one place in memory, and we must know that place ahead of time. Worse, suppose that we want to change the program some day by adding or deleting a line. This will change the addresses of all subsequent words.

A much better system, is to use symbolic addresses:

![](https://miro.medium.com/v2/resize:fit:920/1*DEU96r11tvyEtaqcfHaJDQ.png)

Each line consists of three fields. The first field is for the address, but a symbol is used instead of an absolute numerical. Some lines have no address, implying that the address of that line is one more than the address of the previous line.

For an instruction, the second field contains the three-letter symbol for the opcode. If it is a memory-referencing instruction, then a third field contains a symbolic address.

This is called Assembly Language. Programs written in assembly language (assembly programs) are translated into machine language by anÂ **Assembler**. This program must not only do the symbolic translation, but also assign some form of memory addresses to the symbolic addresses.

## **Key terms in Assembly**

### **Assembler**

A program that translates assembly language into machine code. It takes the basic commands and operations from assembly code and converts

them into binary code that can be recognized by a specific type of processor.

Assembly code consists of lots of ASCII characters; this would be stored in a file calledÂ **source code**. This then forms the input to a assembler which translates the source code into machine code orÂ *object code*.

Popular Assemblers:

â— MASM (Microsoft Macro Assembler)

â— NASM (Netwide Assembler)

â— TASM (Turbo Assembler)

â— GNU Assembler

### **Assembly Language**

A symbolic representation of the machine language of a specific processor, augmented by additional types of statements that facilitate program writing and that provide instructions to the assembler.

### **Compiler**

A program that converts another program from some source language (or programming language) to machine language (object code). Some compilers output assembly language which is then converted to machine language by a separate assembler.

> A compiler is different from an assembler by the fact that each input statement does not correspond to a single machine instruction or fixed sequence of instructions.
> 

A compiler may support such features as automatic allocation of variables, arbitrary arithmetic expressions, control structures such as FOR and WHILE loops, variable scope, input/output operations, higher-order functions and portability of source code.

### **Executable Code**

This is the machine code generated by a source code language processor such as an assembler or compiler. This is software in a form that can be run in the computer.

### **Instruction Set**

The collection of all possible instructions for a particular computer; that is, the collection of machine language instructions that a particular processor understands.

### **Linker**

A utility program that combines one or more files containing object code from separately compiled

program modules into a single file containing loadable or executable code.

Press enter or click to view image in full size

![](https://miro.medium.com/v2/resize:fit:995/1*dKoBrT54YZYy69csk38J4w.png)

### **Loader**

A program routine that copies an executable program into memory for execution

### **Object Code**

The machine language representation of programming source code. Object code is created by a compiler or assembler and is then turned into executable code by the linker.

![Guide to Assembly Language Programming in Linux. Springer-Science Inc. NJ-USA](https://miro.medium.com/v2/resize:fit:530/1*BGVyOTiym8NRP__5MXyrbA.png)

Guide to Assembly Language Programming in Linux. Springer-Science Inc. NJ-USA

# **The main elements of Assembly Language**

Now letâ€™s dive into the main elements of an Assembly program and in the next part weâ€™ll write our first code in Assembly ğŸ˜.

## **Statements**

The heart of any assembly language program are statements. A typical statement in Assembly has the form:

![](https://miro.medium.com/v2/resize:fit:1097/1*Kx0QJgbRaF8FdS1UZkqbvg.png)

## **Label**

If a label is present, the assembler defines the label as equivalent to the address into which the first byte of the object code generated for that instruction will be loaded. The programmer may subsequently use the label as an address or as data in another instructionâ€™s address field.

The assembler replaces the label with the assigned value when creating an object program. Labels are most frequently used in branch instructions. Hereâ€™s an example:

![](https://miro.medium.com/v2/resize:fit:1097/1*JeDKLNz1p9yiIPfUEzasmQ.png)

The program will continue to loop back to location L2 until the result is zero or negative. Thus, when the jg instruction is executed, if the result is positive, the processor places the address equivalent to the label L2 in the program counter.

### **Why do we use Labels?**

1. A label makes a program location easier to find and remember
2. The label can easily be moved to correct a program. The assembler will automatically change the address in all instructions that use the label when the program is reassembled.
3. The programmer does not have to calculate relative or absolute memory addresses, but just uses labels as needed.

## **Mnemonic**

The mnemonic is the name of the operation or function of the assembly

language statement. A statement can correspond to a machine instruction, an assembler directive, or a macro. In the case of a machine

instruction, a mnemonic is the symbolic name associated with a particular opcode.

## **Operand**

An assembly language statement includes zero or more operands. Each

operand identifies an immediate value, a register value, or a memory location. Typically, the assembly language provides conventions for distinguishing among the three types of operand references, as well as conventions for indicating addressing mode.

The x86 architecture has a rich set of addressing modes, each of which must be expressed symbolically in the assembly language:

### **Register Addressing**

For register addressing, the name of the register is used in the instruction. For example;

```
MOV ECX, EBX
```

This copies the contents of register EBX into register ECX.

### **Immediate addressing**

Immediate addressing indicates that the value is encoded in the instruction. For example;

```
MOV EAX, 100H
```

This copies the hexadecimal value 100 into register EAX. The immediate value can also be expressed as a binary number with the suffix B or a decimal number with no suffix. Thus, equivalent statements to the preceding one are

```
MOV EAX, 100000000B
```

and

```
MOV EAX, 256
```

### **Direct addressing**

Direct addressing refers to a memory location and is expressed as a displacement from the DS segment register. This is best explained by example. Assume that the 16-bit data segment register DS contains the value 1000H. Then the following sequence occurs:

```
MOV AX, 1234H
MOV [3518H], AX
```

First the 16-bit register AX is initialized to 1234H. Then, in line two, the contents of AX are moved to the logical address DS:3518. This address formed by shifting the contents of DS left 4 bits and adding 3518H to form the 32-bit logical address 13518H.

## **Sections**

An assembly program has three sections

1. The data section â€” Used for declaring initialized data or constants. This data does not change at runtime.

```
section .data
```

2. The bss section â€” Used for declaring variables

```
section .bss
```

3. The text section â€” used for keep actual code. This section begins with declaration global _start, which tells the kernel where the program execution begins.

```
section .text
```

## **Instructions**

The NASM pseudo-instructions are:

**DB**Â (Define Byte) â€” Allocates 1 byte

**DW**Â (Define Word) â€” Allocates 2 bytes

**DD**Â (Define Doubleword) â€” Allocates 4 bytes

**DQ**Â (Define Quadword) â€” Allocates 8 bytes

**DT**Â (Define Ten Bytes) â€” Allocates 10 bytes

Their uninitialized counterparts are:

**RESB**Â â€” Reserve a Byte

**RESW**Â â€” Reserve a Word

**RESD**Â â€” Reserve a Doubleword

**RESQ**Â â€” Reserve a Quadword

**REST**Â â€” Reserve Ten Bytes

## **System calls**

A system call is a programmatic way in which a computer program requests a service from the kernel. It is the interface between the user space and the kernel space.

The assembler makes use of the x86 INT instruction to make system calls. For example, for Linux systems, the programmer uses the following steps for a system call:

â–  Put the system call number in the EAX register.

â–  Store the arguments to the system call in the registers EBX, ECX, etc.

â–  Call the relevant interrupt (80h).

â–  The result is usually returned in the EAX register.

There are 6 registers that store the arguments of the system call used. These are theÂ **EBX, ECX, EDX, ESI, EDI, and EBP**. These registers take the consecutive arguments, starting with the EBX register. If there are more than six arguments, then the memory location of the first argument is stored in the EBX register.

Here is a table of essential system calls:

![](https://miro.medium.com/v2/resize:fit:1065/1*K-sKImouAUWdBIOgk7YyTg.png)

## **Directives**

A directive is a command embedded in the assembly source code that is recognized and acted upon by the assembler. NASM includes the following directives:

â– Â **BITS**: Specifies whether NASM should generate code designed to run on a processor operating in 16-bit mode, 32-bit mode, or 64-bit mode. The syntax is BITS XX, where XX is 16, 32, or 64. Normally, this is set by default by the operating system.

â– Â **DEFAULT**: Can change some assembler defaults, such as whether to use relative or absolute addressing.

â– Â **SECTION**Â orÂ **SEGMENT**: Changes that section of the output file the source code will be assembled into. This is discussed subsequently.

â– Â **EXTERN**: used to declare a symbol which is not defined anywhere in the

module being assembled, but is assumed to be defined in some other module and needs to be referred to by this one.

â– Â **GLOBAL**: GLOBAL is the other end of EXTERN: if one module declares

a symbol as EXTERN and refers to it, then in order to prevent linker errors,

some other module must actually define the symbol and declare it as GLOBAL.

â– Â **COMMON**: Used to declare common variables. A common variable is much like a global variable declared in the uninitialized data section. The difference is that if more than one module defines the same common variable, then at link time those variables will be merged and will point at the same piece of memory.

â– Â **CPU**: Restricts assembly to those instructions that are available on the specified CPU. For example, this directive can specify 8086, 186, and so on.

â– Â **FLOAT**: Allows the programmer to change some of the default settings to options other than those used in IEEE 754.

# **Writing and running your first Assembly Language code**

Now weâ€™re going to write our first Assembly program!

## **Hello World**

Letâ€™s start with a basic â€œHello Worldâ€ program in assembly. This example is written inÂ **x86 Assembly using NASM**Â (Netwide Assembler) syntax for Linux systems. These are the basic steps:

1. Define the Text to Print: We need to store the message â€œHello World!â€ in memory because assembly directly accesses memory to display text.
2. Use a System Call to Print: In assembly, we donâ€™t have high-level functions likeÂ `print`. Instead, we useÂ **system calls**, which allow us to ask the operating system to perform tasks like writing text to the screen.
3. Exit the Program: We also need to use a system call to properly exit the program.

We can store our â€œHello Worldâ€ code in aÂ `.asm`Â file. To do this, you can use any code editor (like Nano or Vim) in Linux. Weâ€™ll use NeoVim:

```
nvim program.asm
```

Open the terminal and run the above command. This will open the NeoVim editor with a blank file calledÂ `program.asm`. Now you can write your Assembly code in this file.

```nasm
section .data
    hello_msg db "Hello World!", 0xA   ; Define message with a newline at the end

section .text
    global _start                     ; Entry point for the program

_start:
    ; System call to write text to stdout
    mov eax, 4                        ; System call number for sys_write
    mov ebx, 1                        ; File descriptor 1 (stdout)
    mov ecx, hello_msg                ; Message to display
    mov edx, 13                       ; Length of message (including newline)
    int 0x80                          ; Call the kernel

    ; Exit system call
    mov eax, 1                        ; System call number for sys_exit
    xor ebx, ebx                      ; Exit code 0
    int 0x80                          ; Call the kernel to exit
```

Then, save the file.

### **Data Section:**

- We declare the message â€œHello World!â€ in theÂ `.data`Â section. This message is stored as aÂ **string**Â using theÂ `db`Â (define byte) instruction.
- We addÂ `0xA`Â (newline) at the end to move the cursor to a new line after printing.

### **Text Section:**

- We set up theÂ `_start`Â label as the entry point of our program.
- The word â€œglobalâ€ is used when you want the linker to be able to know the address of some a label. The object file generated will contain alink to every label declared â€œglobalâ€. In this case, we have to declareâ€œ_startâ€ as global since it is required for the code to be properly linked.

**The start Label:**

- The â€œ_startâ€ label is essential for all Assembly programs.
- When your program is compiled and later executed, it is executed first at the location of â€œ_startâ€.
- If the linker cannot find â€œ_startâ€, it will throw an error.

**Printing the Message**:

- We use theÂ `mov`Â instruction to load registers with specific values for aÂ `sys_write`Â system call.
- `eax = 4`: System call number forÂ `sys_write`.
- `ebx = 1`: File descriptor forÂ **standard output (stdout)**.
- `ecx = hello_msg`: The address of our message to display.
- `edx = 13`: The length of the message (characters plus newline).
- `int 0x80`: This instruction calls the Linux kernel to execute theÂ `sys_write`Â command.

**Exiting the Program**:

- `eax = 1`: System call number forÂ `sys_exit`.
- `ebx = ebx`: Exit code 0, indicating successful execution.

*The reason why we do ebx, ebx instead of ebx, 0 to set the exit code to 0, is because the former is more efficient.*

- `int 0x80`: Calls the kernel to exit the program.

## **Running Assembly code in Linux**

Now I think you know how to handle basic input/output in Assembly. But how do we run this in a Linux terminal? Hereâ€™s a step-by-step guide:

### 1. Installing nasm

This installation guide is geared towards Arch Linux users as this is my system of choice. The process should be just as straightforward on other distros or operating systems. Installing **NASM (Netwide Assembler)** on Arch Linux is straightforward because it is available in the official **extra** repository. Open your terminal and run the following command to update your package database and install NASM:

```bash
sudo pacman -S nasm
```

After the process completes, you can verify that NASM is installed correctly by checking its version:

```bash
nasm -v
```

You should see output similar to: `NASM version 2.16.03 compiled on ...`

### **2. Create the .o (object) file**

The assembler (NASM) has to take yourÂ `.asm`Â file and translate it into machine code that can be processed by the computer. This translation results in an intermediateÂ `.o`Â file, which contains the binary code but is not yet executable. You can generate this file using the command using:

```
nasm -f elf64 -o program.o program.asm
```

Here,Â `-f elf64`Â specifies the format (64-bit ELF format, used in Linux), andÂ `-o program.o`Â specifies the output file name. Now link it:

### **3. Create the executable file**

```bash
ld program.o -o program
```

Now you can run the executable using:

Here,Â `-o program`Â specifies the name of the output executable file. After this step, the executableÂ `program`Â can be run directly from the terminal with:

```
./program
```

### **4. Makefile**

We can automate the above process using Makefile. This is a configuration file in Linux used by theÂ `make`Â build automation tool, to compile and link programs. For assembly programs, a Makefile is particularly useful for organizing and automating the assembly, linking, and running steps, making it easier to manage programs.

You can create the Makefile using nano. Hereâ€™s a Makefile that assembles, links, and runs the above program:

```makefile
# Compiler and flags
ASM = nasm
ASM_FLAGS = -f elf64

# Executable and object names
TARGET = program
OBJECT = program.o

# Default rule to build and run the program
all: $(TARGET)

# Rule to assemble the .asm file into an object file
$(OBJECT): program.asm
  $(ASM) $(ASM_FLAGS) -o $(OBJECT) program.asm

# Rule to link the object file into an executable
$(TARGET): $(OBJECT)
  ld -o $(TARGET) $(OBJECT)

# Clean rule to remove generated files
clean:
  rm -f $(OBJECT) $(TARGET)
```

**Variables**:Â `ASM`,Â `ASM_FLAGS`,Â `TARGET`, andÂ `OBJECT`Â make the Makefile easier to adjust for different programs or flags.

- `ASM`Â is the assembler (NASM in this case).
- `ASM_FLAGS`Â includes options for NASM, such asÂ `f elf64`Â for 64-bit object files.
- `TARGET`Â is the name of the executable to produce.
- `OBJECT`Â is the object file name.

**Rules**:

- **all**: This is the default target. RunningÂ `make`Â will build the executable and then run it (`./program`).
- **$(OBJECT)**: This target assemblesÂ `program.asm`Â intoÂ `program.o`.
- **$(TARGET)**: This target links the object file to create the final executable.
- **clean**: This target removes any generated files (`program.o`Â andÂ `program`) to allow a clean build.

To build and run the Makefile just run:

```
make
```

This Makefile automates assembling, linking, and running your assembly code, which is especially useful when you need to modify and re-run code frequently.
